#!/bin/bash
LC_ALL=C

export WTFSCACHE
export WTFSCACHEROOT
export WTFSCACHEMOUNT
export WTFSCACHEMETA
export WTFSCACHETMP

export min_free
export max_free
export remote
export backups
export startup
export master_timeout
export master_poll

#DONE: start:: start the daemon
#DONE: pin:: files to a 'precious' dir which doesnt get garbage collected
#DONE: get:: force caching the given files
#DONE: drop:: files from the cache --pin drops pinned files
#DONE: config loader
#DONE: status file
#DONE: disconnect:: manual disconnected operation
#DONE: connect:: reconnect after a (manual) disconnection
#DONE: fix offline detection
#DONE: init:: setup a template
#DONE: status:: print some infos
#DONE: detach/local:: detach files from the remote, keep edits local
#DONE: merge:: merge detached files back to the remote
#DONE: detach offline commits
#DONE: automerge:: merge detached files back to the remote
#DONE: logfile for files which need to be merged (automatically detached)
#DONE: stop:: stop command

#v0.1:

#PLANNED: global cache, move metadata to ~/.wtfscache/<md5sum>/
#PLANNED: global config for gc etc


#later:

#PLANNED: config for merge (auto/manual)
#PLANNED: ignore patterns for copy_up, config copyup behaviour
#PLANNED: gc pinned files for min_free
#PLANNED: verify level: before deleting: none, exists, compare

#TODO: unpin:: precious -> cache
#TODO: prune:: remove all traces of a file, including backups, also from master
#TODO: ???:: propagate deleted files to the remote mode=writeback, local, deletes
#TODO: undelete/undo/history:: work with backup files and whiteouts
#TODO: clean/gc:: manual gc run
#TODO: caching/copy_up configureable, only cow by pattern?
#PLANNED: --connect/--disconnect option for start
#FIXME: filenames with leading/trailing spaces

function dbg ()
{
    echo "$*" 1>&2
}

function die ()
{
    echo "$*" 1>&2
    exit 1
}

function disk_free ()
{
    echo -n $(df -B 1M --no-sync --output=avail -l "$1" | tail -1)
}

function gc ()
{
    dbg "GC $(disk_free "$WTFSCACHEMETA/cache/.")"
    if [[ ! -f "$WTFSCACHEMETA/$$.lst" ]] && (($(disk_free "$WTFSCACHEMETA/cache/.") <= $min_free)); then
            find "$WTFSCACHEMETA/cache" -type f -not -name '*_HIDDEN~' -printf '%A@ %p\n' | sort -n  >"$WTFSCACHEMETA/$$.lst"

            while (($(disk_free "$WTFSCACHEMETA/cache/.") < $max_free)); do
                read _ file || break
                dbg "RM $file"
                #FIXME: only when proven that file exist on remote
                [[ -f $file ]] && rm "$file"
            done <"$WTFSCACHEMETA/$$.lst"

            #TODO: prune empty dirs
            rm "$WTFSCACHEMETA/$$.lst"
    fi
}

function check_connection ()
{
    source "$WTFSCACHEMETA/status"
    if [[ "$status" == connected ]] && ! { timeout -s9 ${master_timeout} touch -ac "$WTFSCACHEMETA/master/."; } 2>/dev/null ; then
            fusermount -u -z "$WTFSCACHEMETA/master"
            status=offline
            write_status
    elif [[ "$status" == offline ]]; then
            if sshfs -o compression=yes,reconnect,ServerAliveInterval=15,ServerAliveCountMax=3,idmap=user "$remote" "$WTFSCACHEMETA/master" >&/dev/null; then
                    status=connected
                    write_status
                    auto_merge
            fi
    fi
}

function poll_connection ()
{
    while sleep "$master_poll"; do
        check_connection
    done
}

function wtfscache_disconnect ()
{
    setup "$1"
    fusermount -u -z "$WTFSCACHEMETA/master"
    status=disconnected
    write_status
}

function wtfscache_connect ()
{
    setup "$1"

    if [[ "$status" != connected ]]; then
            if sshfs -o compression=yes,reconnect,ServerAliveInterval=15,ServerAliveCountMax=3,idmap=user "$remote" "$WTFSCACHEMETA/master"; then
                status=connected
            else
                status=offline
            fi
    fi
    write_status
    auto_merge
}

function copy_up ()
{
    check_connection

    if [[ "$status" == connected && ! ( -f "$WTFSCACHEMETA/cache/${1}"
           || -f "$WTFSCACHEMETA/precious/${1}"
           || -f "$WTFSCACHEMETA/local/${1}" ) ]]; then
            dbg "COPY_UP $1"
            touch -ac "$WTFSCACHEMOUNT/$1"
            gc
    fi
}

function commit ()
{
    local merge="$1"
    if [[ "$merge" == '--merge' ]]; then
            shift
            dbg "MERGE $1"
    fi

    [[ "$merge" != '--merge' && -f "$WTFSCACHEMETA/local/${1}" ]] && return

    check_connection

    if [[ "$status" == connected ]]; then
            dbg "COMMIT $1"
            local dir="/${1}"
            dir="${dir%/*}"

            mkdir -p "$WTFSCACHEMETA/master/$dir"

            if [[ -f "$WTFSCACHEMETA/cache/${1}" ]]; then
                    cp --backup="$backups" "$WTFSCACHEMETA/cache/${1}" "$WTFSCACHEMETA/master/${1}"
            elif [[ -f "$WTFSCACHEMETA/precious/${1}" ]]; then
                    cp --backup="$backups" "$WTFSCACHEMETA/precious/${1}" "$WTFSCACHEMETA/master/${1}"
            elif [[ "$merge" == '--merge' && -f "$WTFSCACHEMETA/local/${1}" ]]; then
                    cp --backup="$backups" "$WTFSCACHEMETA/local/${1}" "$WTFSCACHEMETA/master/${1}"
            fi
    else
        if [[ -f "$WTFSCACHEMETA/cache/${1}" ]]; then
                echo "cached ${1}" >>"$WTFSCACHEMETA/detached.log"
        elif [[ -f "$WTFSCACHEMETA/precious/${1}" ]]; then
                echo "pinned ${1}" >>"$WTFSCACHEMETA/detached.log"
        else
            return
        fi
        dbg "AUTO_DETACH $1"
        detach_file "$1"
    fi
}


function var ()
{
    echo "$1='${!1}'"
}


function write_status ()
{
    status_time=$(date -u +%s)
    dbg "STATUS $status"
    cat >"$WTFSCACHETMP/status" <<EOF
$(var status_time)
$(var status)
$(var pid)
EOF
}


function file_status
{
    [[ -f "$WTFSCACHEMETA/cache/$1" ]] && { echo "cached"; return; }
    [[ -f "$WTFSCACHEMETA/precious/$1" ]] && { echo "pinned"; return; }
    [[ -f "$WTFSCACHEMETA/local/$1" ]] && { echo "detached"; return; }
    [[ "$status" == 'connected' ]] && [[ -f "$WTFSCACHEMETA/master/$1" ]] && { echo "remote"; return; }
}


function normalize_filename ()
{
    local file="$(readlink -m "$1")"
    echo "${file##$WTFSCACHEMOUNT/}"
}


function wtfscache_status ()
{
    setup "$1"

    echo "Mountpoint: $WTFSCACHEMOUNT"
    echo "State: $status"
    echo "Cached: $(du -sh "$WTFSCACHEMETA/cache" | awk '{print $1}')"
    echo "Pinned: $(du -sh "$WTFSCACHEMETA/precious" | awk '{print $1}')"
    echo "Local: $(du -sh "$WTFSCACHEMETA/local" | awk '{print $1}')"
    [[ "$status" == 'connected' ]] && echo "Remote: $(du -sh "$WTFSCACHEMETA/master" | awk '{print $1}')"

    for i in "$@"; do
        if [[ -f "$i" ]]; then
                echo
                local file="$(normalize_filename "$i")"

                echo "$file"
                echo " Status: $(file_status "$file")" #TODO: unmerged
                echo " Size: $(du -sh "$WTFSCACHEMOUNT/$file" | awk '{print $1}')"
        fi
    done
}



function wtfscache_start ()
{
    WTFSCACHE="$1"
    WTFSCACHEROOT="${PWD}"
    WTFSCACHEMOUNT="$WTFSCACHEROOT/$WTFSCACHE"
    WTFSCACHEMETA="$WTFSCACHEROOT/.$WTFSCACHE"
    WTFSCACHETMP="$WTFSCACHEROOT/.$WTFSCACHE"

    [[ -f "$WTFSCACHEMETA/config" ]] || die "not a wtfscache"
    source "$WTFSCACHEMETA/config"

    pid="$$"
    status="$startup"

    unionfs-fuse -o cow,use_ino "$WTFSCACHEMETA/cache"=RW:"$WTFSCACHEMETA/precious"=RW:"$WTFSCACHEMETA/local"=RW:"$WTFSCACHEMETA/master"=RO "$WTFSCACHE"

    if [[ "$startup" == 'connected' ]]; then
            sshfs -o compression=yes,reconnect,ServerAliveInterval=15,ServerAliveCountMax=3,idmap=user "$remote" "$WTFSCACHEMETA/master" || status=offline
    fi

    write_status

    cd "$WTFSCACHEROOT"

    trap : INT

    gc

    #TODO: no polling when disconnected
    poll_connection &
    [[ "$status" == 'connected' ]] && auto_merge &

    # loop? restart? what about new dirs?
    inotifywait -m -r --format '%e %w%f' -e open,close_write "$WTFSCACHE" | xargs -d '\n' -l -P 32 -n1 $0 EVENT

    dbg "
DONE"
    fusermount -u -z "$WTFSCACHE"
    source "$WTFSCACHEMETA/status"
    [[ "$status" == 'connected' ]] && fusermount -u -z "$WTFSCACHEMETA/master"
    rm "$WTFSCACHEMETA/status"
}



function query ()
{
    read -p "$1
$2 = [$3] "
    echo "# $1
$2='${REPLY:-$3}'

"
}




function wtfscache_init ()
{
    WTFSCACHE="$1"
    WTFSCACHEROOT="${PWD}"
    WTFSCACHEMOUNT="$WTFSCACHEROOT/$WTFSCACHE"
    WTFSCACHEMETA="$WTFSCACHEROOT/.$WTFSCACHE"
    WTFSCACHETMP="$WTFSCACHEROOT/.$WTFSCACHE"

    mkdir -p "$WTFSCACHE" "$WTFSCACHEMETA/cache" "$WTFSCACHEMETA/master" "$WTFSCACHEMETA/precious" "$WTFSCACHEMETA/local/.wtfscache"
    [[ -f "$WTFSCACHEMETA/local/.wtfscache/name" ]] || echo "$WTFSCACHE" >"$WTFSCACHEMETA/local/.wtfscache/name"

    [[ -f "$WTFSCACHEMETA/config" ]] || cat >"$WTFSCACHEMETA/config" <<EOF
$(query 'Starting garbage collector when less then this MB space is free' min_free 1024)
$(query 'Stopping the gc when this much MB space is free' max_free 2048)
$(query "Master server as 'user@host:directory'" remote '')
$(query 'Backup mode' backups numbered)
$(query 'Startup state (connected/disconnected)' startup connected)
$(query 'Timeout for for connecting master' master_timeout 5)
$(query 'Timeout for for polling master' master_poll 10)
EOF
}

function setup ()
{
    local startdir="$PWD"
    cd "${1%/*}"

    while [[ "$PWD" != '/' && ! -f ".wtfscache/name" ]]; do
        cd ..
    done

    if [[ -f ".wtfscache/name" ]]; then
            WTFSCACHE="$(<.wtfscache/name)"
            WTFSCACHEROOT="${PWD%/*}"
            WTFSCACHEMOUNT="$WTFSCACHEROOT/$WTFSCACHE"
            WTFSCACHEMETA="$WTFSCACHEROOT/.$WTFSCACHE"
            WTFSCACHETMP="$WTFSCACHEROOT/.$WTFSCACHE"
    else
        die "no wtfscache or not started"
    fi

    cd "$startdir"
    source "$WTFSCACHEMETA/config"
    source "$WTFSCACHEMETA/status"
}

function get ()
{
    local pin="$1"
    if [[ "$pin" == '--pin' ]]; then
            shift
    fi

    setup "$1"

    for i in "$@"; do
        local file="$(normalize_filename "$i")"
        if [[ -f "$WTFSCACHEMOUNT/$file" ]]; then
                copy_up "$file"
                if [[ "$pin" == '--pin' ]]; then
                        dbg "PIN ${file}"
                        local dir="/${file}"
                        dir="${dir%/*}"
                        mkdir -p "$WTFSCACHEMETA/precious/$dir}"
                        [[ -f "$WTFSCACHEMETA/cache/${file}" ]] && mv "$WTFSCACHEMETA/cache/${file}" "$WTFSCACHEMETA/precious/${file}"
                fi
        #PLANNED: else pattern?
        fi
    done
}


function drop ()
{
    local pin="$1"
    if [[ "$pin" == '--pin' ]]; then
            shift
    fi
    setup "$1"

    for i in "$@"; do
        local file="$(normalize_filename "$i")"
        if [[ -f "$WTFSCACHEMOUNT/$file" ]]; then
                dbg "DROP ${file}"

                #TODO: check for existence in remote
                [[ -f "$WTFSCACHEMETA/cache/${file}" ]] && rm "$WTFSCACHEMETA/cache/${file}"

                if [[ -f "$WTFSCACHEMETA/precious/${file}" ]]; then
                        if [[ "$pin" == '--pin' ]]; then
                                rm -f "$WTFSCACHEMETA/precious/${file}"
                        else
                            dbg "PINNED ${file}"
                        fi
                fi

                if [[ -f "$WTFSCACHEMETA/local/${file}" ]]; then
                        if cmp "$WTFSCACHEMETA/master/${file}" "$WTFSCACHEMETA/local/${file}" >&/dev/null; then
                                rm -f "$WTFSCACHEMETA/local/${file}"
                        else
                            dbg "UNMERGED ${file}"
                        fi
                fi
        #PLANNED: else pattern?
        fi
    done
}


function detach_file ()
{
    dbg "DETACH ${1}"
    local dir="/${1}"
    dir="${dir%/*}"

    mkdir -p "$WTFSCACHEMETA/local/$dir"
    if [[ -f "$WTFSCACHEMETA/cache/${1}" ]]; then
            mv "$WTFSCACHEMETA/cache/${1}" "$WTFSCACHEMETA/local/${1}"
    elif [[ -f "$WTFSCACHEMETA/precious/${1}" ]]; then
            mv "$WTFSCACHEMETA/precious/${1}" "$WTFSCACHEMETA/local/${1}"
    else
        dbg "NOT_AVAILABLE ${1}"
    fi
}


function detach ()
{
    setup "$1"

    for i in "$@"; do
        local file="$(normalize_filename "$i")"
        if [[ -f "$WTFSCACHEMOUNT/$file" && ! -f "$WTFSCACHEMETA/local/${file}" ]]; then
                copy_up "$file"
                detach_file "$file"
        #PLANNED: else pattern?
        fi
    done
}

function merge ()
{
    setup "$1"

    for i in "$@"; do
        local file="$(normalize_filename "$i")"
        if [[ -f "$WTFSCACHEMETA/local/${file}" ]]; then
                commit --merge "$file"
        fi
    done
}


function auto_merge ()
{
    if [[ -f "$WTFSCACHEMETA/detached.log" ]]; then
            while read where file; do
                if [[ -f "$WTFSCACHEMETA/local/${file}" ]]; then
                        commit --merge "$file"
                        if [[ "$where" == 'cached' ]]; then
                                mv "$WTFSCACHEMETA/local/${file}" "$WTFSCACHEMETA/cache/${file}"
                        elif [[ "$where" == 'pinned' ]]; then
                                mv "$WTFSCACHEMETA/local/${file}" "$WTFSCACHEMETA/precious/${file}"
                        fi
                fi
            done <"$WTFSCACHEMETA/detached.log"
            rm "$WTFSCACHEMETA/detached.log"
    fi
}


case "$1" in
init)
    shift
    wtfscache_init "$@"
    ;;
start)
    shift
    wtfscache_start "$@"
    ;;
stop)
    shift
    setup "$1"
    kill -INT -"$pid"
    ;;
disconnect)
    shift
    wtfscache_disconnect "$@"
    ;;
connect)
    shift
    wtfscache_connect "$@"
    ;;
status)
    shift
    wtfscache_status "$@"
    ;;
get)
    shift
    get "$@"
    ;;
pin)
    shift
    get --pin "$@"
    ;;
detach)
    shift
    detach "$@"
    ;;
merge)
    shift
    merge "$@"
    ;;
drop)
    shift
    drop "$@"
    ;;
EVENT)
    shift
    case "$1" in
    "OPEN,ISDIR "*)
        :
        ;;
    "OPEN "*)
        copy_up "${1##OPEN $WTFSCACHE/}"
        ;;
    "CLOSE_WRITE,CLOSE "*)
        commit "${1##CLOSE_WRITE,CLOSE $WTFSCACHE/}"
        ;;
    *)
        die "unhandled event $@"
    esac
    ;;
*)
    die "unknown command $1"
    ;;
esac


